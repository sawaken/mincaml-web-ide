// Generated by CoffeeScript 1.10.0
var MismatchedTypeError, Type, TypeChecker, UnboundVariableError, UnexpectedTypeError, UnifyError, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

if (typeof require !== "undefined" && require !== null) {
  ref = require(__dirname + '/type.coffee'), Type = ref.Type, UnifyError = ref.UnifyError;
}

TypeChecker = (function() {
  function TypeChecker(ast1) {
    this.ast = ast1;
    this.idCounter = 0;
  }

  TypeChecker.prototype.check = function() {
    return this.typing(this.ast, []);
  };

  TypeChecker.prototype.newTypeVar = function() {
    return new Type(this.idCounter++);
  };

  TypeChecker.prototype.newTupleType = function(typeArgs) {
    return new Type(this.idCounter++, 'Tuple', typeArgs);
  };

  TypeChecker.prototype.newFuncType = function(left, right) {
    return new Type(this.idCounter++, 'Func', [left, right]);
  };

  TypeChecker.prototype.newIntType = function() {
    return new Type(this.idCounter++, 'Int');
  };

  TypeChecker.prototype.newBoolType = function() {
    return new Type(this.idCounter++, 'Bool');
  };

  TypeChecker.prototype.newUnitType = function() {
    return new Type(this.idCounter++, 'Unit');
  };

  TypeChecker.prototype.unifyOneAST = function(ast, type) {
    var error, error1;
    try {
      return ast.expType.unify(type);
    } catch (error1) {
      error = error1;
      if (error instanceof UnifyError) {
        throw new UnexpectedTypeError(ast, type);
      } else {
        throw error;
      }
    }
  };

  TypeChecker.prototype.unifyTwoAST = function(astA, astB) {
    var error, error1;
    try {
      return astA.expType.unify(astB.expType);
    } catch (error1) {
      error = error1;
      if (error instanceof UnifyError) {
        throw new MismatchedTypeError(astA, astB);
      } else {
        throw error;
      }
    }
  };

  TypeChecker.prototype.typing = function(ast, env) {
    var _, e, expType, funcExpType, funcType, i, idx, j, k, len, len1, len2, name, newBodyEnv, newEnv, newFuncEnv, obj, obj1, obj2, ref1, ref2, resolved, t, varTable, varTypes;
    switch (ast.syntax) {
      case 'if':
        this.typing(ast.condExp, env);
        this.typing(ast.thenExp, env);
        this.typing(ast.elseExp, env);
        this.unifyOneAST(ast.condExp, this.newBoolType());
        this.unifyTwoAST(ast.thenExp, ast.elseExp);
        return ast.expType = ast.thenExp.expType;
      case 'let':
        this.typing(ast.varExp, env);
        newEnv = [
          (
            obj1 = {},
            obj1["" + ast.varName.string] = ast.varExp.expType,
            obj1
          )
        ].concat(env);
        return ast.expType = this.typing(ast.bodyExp, newEnv);
      case 'let-rec':
        funcExpType = this.newTypeVar();
        funcType = funcExpType;
        varTable = {};
        ref1 = ast.funcParamNames.slice().reverse();
        for (i = 0, len = ref1.length; i < len; i++) {
          name = ref1[i];
          t = this.newTypeVar();
          varTable[name.string] = t;
          funcType = this.newFuncType(t, funcType);
        }
        newBodyEnv = [
          (
            obj2 = {},
            obj2["" + ast.funcName.string] = funcType,
            obj2
          )
        ].concat(env);
        newFuncEnv = [varTable].concat(newBodyEnv);
        this.typing(ast.funcExp, newFuncEnv);
        this.unifyOneAST(ast.funcExp, funcExpType);
        return ast.expType = this.typing(ast.bodyExp, newBodyEnv);
      case 'let-tuple':
        this.typing(ast.tupleExp, env);
        varTypes = (function() {
          var j, len1, ref2, results;
          ref2 = ast.varNames;
          results = [];
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            _ = ref2[j];
            results.push(this.newTypeVar());
          }
          return results;
        }).call(this);
        this.unifyOneAST(ast.tupleExp, this.newTupleType(varTypes));
        varTable = {};
        ref2 = ast.varNames;
        for (idx = j = 0, len1 = ref2.length; j < len1; idx = ++j) {
          name = ref2[idx];
          varTable[name.string] = varTypes[idx];
        }
        this.typing(ast.bodyExp, [varTable].concat(env));
        return ast.expType = ast.bodyExp.expType;
      case 'apply':
        expType = this.newTypeVar();
        funcType = this.newFuncType(this.typing(ast.rightExp, env), expType);
        this.typing(ast.leftExp, env);
        this.unifyOneAST(ast.leftExp, funcType);
        return ast.expType = expType;
      case 'eq':
      case 'le':
        this.typing(ast.leftExp, env);
        this.typing(ast.rightExp, env);
        this.unifyOneAST(ast.leftExp, this.newIntType());
        this.unifyOneAST(ast.rightExp, this.newIntType());
        return ast.expType = this.newBoolType();
      case 'eq':
      case 'le':
      case 'add':
      case 'sub':
      case 'mul':
      case 'div':
        this.typing(ast.leftExp, env);
        this.typing(ast.rightExp, env);
        this.unifyOneAST(ast.leftExp, this.newIntType());
        this.unifyOneAST(ast.rightExp, this.newIntType());
        return ast.expType = this.newIntType();
      case 'not':
        this.typing(ast.exp, env);
        this.unifyOneAST(ast.exp, this.newBoolType());
        return ast.expType = this.newBoolType();
      case 'neg':
        this.typing(ast.exp, env);
        this.unifyOneAST(ast.exp, this.newIntType());
        return ast.expType = this.newIntType();
      case 'tuple':
        return ast.expType = this.newTupleType((function() {
          var k, len2, ref3, results;
          ref3 = ast.exps;
          results = [];
          for (k = 0, len2 = ref3.length; k < len2; k++) {
            e = ref3[k];
            results.push(this.typing(e, env));
          }
          return results;
        }).call(this));
      case 'parenthesis':
        return ast.expType = this.typing(ast.exp, env);
      case 'var-ref':
        resolved = null;
        for (k = 0, len2 = env.length; k < len2; k++) {
          obj = env[k];
          if (obj.hasOwnProperty(ast.string)) {
            return ast.expType = obj[ast.string];
          }
        }
        throw new UnboundVariableError(ast);
        break;
      case 'bool':
        return ast.expType = this.newBoolType();
      case 'int':
        return ast.expType = this.newIntType();
      case 'unit':
        return ast.expType = this.newUnitType();
    }
  };

  return TypeChecker;

})();

MismatchedTypeError = (function(superClass) {
  extend(MismatchedTypeError, superClass);

  function MismatchedTypeError(astA1, astB1) {
    this.astA = astA1;
    this.astB = astB1;
  }

  return MismatchedTypeError;

})(Error);

UnexpectedTypeError = (function(superClass) {
  extend(UnexpectedTypeError, superClass);

  function UnexpectedTypeError(ast1, type1) {
    this.ast = ast1;
    this.type = type1;
  }

  return UnexpectedTypeError;

})(Error);

UnboundVariableError = (function(superClass) {
  extend(UnboundVariableError, superClass);

  function UnboundVariableError(ast1) {
    this.ast = ast1;
  }

  return UnboundVariableError;

})(Error);

if (typeof exports !== "undefined" && exports !== null) {
  exports.TypeChecker = TypeChecker;
  exports.MismatchedTypeError = MismatchedTypeError;
  exports.UnexpectedTypeError = UnexpectedTypeError;
  exports.UnboundVariableError = UnboundVariableError;
}
