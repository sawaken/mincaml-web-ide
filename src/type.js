// Generated by CoffeeScript 1.10.0
var Type, UnifyError,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Type = (function() {
  function Type(id, typeName, typeArgs) {
    this.id = id;
    this.typeName = typeName != null ? typeName : null;
    this.typeArgs = typeArgs != null ? typeArgs : [];
    this.parent = null;
  }

  Type.prototype.root = function() {
    if (this.parent !== null) {
      return this.parent = this.parent.root();
    } else {
      return this;
    }
  };

  Type.prototype.getTypeName = function() {
    return this.root().typeName;
  };

  Type.prototype.getTypeArgs = function() {
    return this.root().typeArgs;
  };

  Type.prototype.unify = function(other) {
    var i, idx, len, ref, v;
    if (this.same(other)) {
      return;
    }
    if (this.getTypeName() !== null && other.getTypeName() !== null) {
      if (this.getTypeName() !== other.getTypeName()) {
        throw new UnifyError(this, other);
      }
      if (this.getTypeArgs().length !== other.getTypeArgs().length) {
        throw new UnifyError(this, other);
      }
      ref = this.getTypeArgs();
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        v = ref[idx];
        v.unify(other.getTypeArgs()[idx]);
      }
      return this.root().parent = other;
    } else if (this.getTypeName() === null && other.getTypeName() !== null) {
      if (other.occurCheck(this)) {
        return this.root().parent = other;
      } else {
        throw new UnifyError(this, other);
      }
    } else if (this.getTypeName() !== null && other.getTypeName() === null) {
      if (this.occurCheck(other)) {
        return other.root().parent = this;
      } else {
        throw new UnifyError(this, other);
      }
    } else if (this.getTypeName() === null && other.getTypeName() === null) {
      return this.root().parent = other;
    }
  };

  Type.prototype.occurCheck = function(t) {
    var ch, i, len, ref;
    if (this.same(t)) {
      return false;
    }
    ref = this.getTypeArgs();
    for (i = 0, len = ref.length; i < len; i++) {
      ch = ref[i];
      if (!ch.occurCheck(t)) {
        return false;
      }
    }
    return true;
  };

  Type.prototype.same = function(other) {
    return this.root() === other.root();
  };

  Type.prototype.toString = function() {
    var a, l, leftStr, r, ref, rightStr;
    if (this.getTypeName() === null) {
      return 'a' + this.root().id.toString();
    } else {
      switch (this.getTypeName()) {
        case 'Func':
          ref = this.getTypeArgs(), l = ref[0], r = ref[1];
          leftStr = l.getTypeName() === 'Func' ? "(" + (l.toString()) + ")" : l.toString();
          rightStr = r.toString();
          return leftStr + ' -> ' + rightStr;
        case 'Tuple':
          return '(' + ((function() {
            var i, len, ref1, results;
            ref1 = this.getTypeArgs();
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              a = ref1[i];
              results.push(a.toString());
            }
            return results;
          }).call(this)).join(', ') + ')';
        default:
          return this.getTypeName();
      }
    }
  };

  return Type;

})();

UnifyError = (function(superClass) {
  extend(UnifyError, superClass);

  function UnifyError(a1, b) {
    this.a = a1;
    this.b = b;
  }

  UnifyError.prototype.toString = function() {
    return "Cannot unify " + (this.a.toString()) + " and " + (this.b.toString());
  };

  return UnifyError;

})(Error);

if (typeof exports !== "undefined" && exports !== null) {
  exports.Type = Type;
  exports.UnifyError = UnifyError;
}
