// Generated by CoffeeScript 1.10.0
var Closure, Continuation, Dispatcher, MismatchedTypeError, Program, Store, TextConverter, TypeChecker, UnboundVariableError, UnexpectedTypeError, fs, grammerFile, mincamlParser, peg, ref, ref1;

if (typeof require !== "undefined" && require !== null) {
  TextConverter = require(__dirname + '/text-converter.coffee').TextConverter;
  ref = require(__dirname + '/type-checker.coffee'), TypeChecker = ref.TypeChecker, MismatchedTypeError = ref.MismatchedTypeError, UnexpectedTypeError = ref.UnexpectedTypeError, UnboundVariableError = ref.UnboundVariableError;
  peg = require('pegjs');
  fs = require('fs');
  grammerFile = __dirname + '/../parser/mincaml-parser.pegjs';
  mincamlParser = peg.buildParser(fs.readFileSync(grammerFile, 'utf8'));
  ref1 = require(__dirname + '/interpreter.coffee'), Program = ref1.Program, Closure = ref1.Closure, Continuation = ref1.Continuation;
}

Store = (function() {
  Store.Execution = {
    Stopping: 1,
    Breaking: 2,
    Running: 3
  };

  Store.CodeStatus = {
    Ok: 1,
    SyntaxError: 2,
    TypeError: 3,
    VarError: 4,
    Unknown: 5
  };

  function Store() {
    this.editor = {
      caretLeftPos: 0,
      caretTopPos: 0,
      caretVisible: false,
      caretFlashing: false,
      ornamentalCode: "",
      rowCode: "",
      lineNumbers: 1,
      breakpointLineMap: [],
      lastKeytypedTime: 0,
      focusing: false
    };
    this.currentTime = 0;
    this.codeStatus = Store.CodeStatus.Unknown;
    this.execution = {
      status: Store.Execution.Stopping,
      program: null
    };
    this.console = {
      status: '',
      results: []
    };
  }

  Store.prototype.nowTyping = function(delay) {
    return this.editor.lastKeytypedTime > this.currentTime - delay;
  };

  Store.prototype.nowEditing = function() {
    return this.nowTyping(1000);
  };

  return Store;

})();

Dispatcher = (function() {
  function Dispatcher(store) {
    this.store = store;
  }

  Dispatcher.prototype.setCode = function(rowCode) {
    if (this.store.nowEditing()) {
      return this.setCodeWithoutCheck(rowCode);
    } else {
      if (this.store.codeStatus === Store.CodeStatus.Unknown) {
        return this.setCodeWithCheck(rowCode);
      } else {

      }
    }
  };

  Dispatcher.prototype.setCodeWithoutCheck = function(rowCode) {
    var escapedRowCode;
    escapedRowCode = TextConverter.escapeTag(rowCode);
    this.store.codeStatus = Store.CodeStatus.Unknown;
    this.store.console.status = '';
    this.store.editor.rowCode = rowCode;
    return this.store.editor.ornamentalCode = TextConverter.decorate(escapedRowCode);
  };

  Dispatcher.prototype.setCodeWithCheck = function(rowCode) {
    var code, error;
    code = (function() {
      var error1;
      try {
        (new TypeChecker(mincamlParser.parse(rowCode))).check();
        this.store.codeStatus = Store.CodeStatus.Ok;
        this.store.console.status = '';
        return rowCode;
      } catch (error1) {
        error = error1;
        if (error instanceof UnexpectedTypeError) {
          this.store.codeStatus = Store.CodeStatus.TypeError;
          this.store.console.status = ((error.type.toString()) + " is expected ") + ("but the actual is " + (error.ast.expType.toString()));
          return TextConverter.multiMark(rowCode, [
            {
              location: error.ast.location,
              className: 'exp-error'
            }
          ]);
        } else if (error instanceof UnboundVariableError) {
          this.store.codeStatus = Store.CodeStatus.VarError;
          this.store.console.status = "Unbound variable `" + error.ast.string + "`";
          return TextConverter.multiMark(rowCode, [
            {
              location: error.ast.location,
              className: 'exp-error'
            }
          ]);
        } else if (error instanceof MismatchedTypeError) {
          this.store.codeStatus = Store.CodeStatus.TypeError;
          this.store.console.status = "cannot unify " + ((error.astA.expType.toString()) + " and " + (error.astB.expType.toString()));
          return TextConverter.multiMark(rowCode, [
            {
              location: error.astA.location,
              className: 'exp-error'
            }, {
              location: error.astB.location,
              className: 'exp-error'
            }
          ]);
        } else if (error.name === 'SyntaxError') {
          this.store.codeStatus = Store.CodeStatus.SyntaxError;
          this.store.console.status = rowCode === '' ? '' : error.message;
          return TextConverter.multiMark(rowCode, [
            {
              location: error.location,
              className: 'position-error'
            }
          ]);
        } else {
          throw error;
        }
      }
    }).call(this);
    this.store.editor.rowCode = rowCode;
    return this.store.editor.ornamentalCode = TextConverter.decorate(code);
  };

  Dispatcher.prototype.setLineInfo = function(rowCode) {
    var lc, newMap;
    lc = TextConverter.lines(rowCode).length;
    newMap = this.store.editor.breakpointLineMap.slice(0, lc + 1);
    this.store.editor.lineNumbers = lc;
    return this.store.editor.breakpointLineMap = newMap;
  };

  Dispatcher.prototype.setCaret = function(leftPos, topPos) {
    this.store.editor.caretLeftPos = leftPos;
    return this.store.editor.caretTopPos = topPos;
  };

  Dispatcher.prototype.startProgram = function(validRowCode) {
    var ast, program;
    if (this.store.execution.status === Store.Execution.Stopping) {
      ast = mincamlParser.parse(validRowCode);
      (new TypeChecker(ast)).check();
      program = new Program(ast);
      Program.markLineHeads(ast);
      this.store.execution.status = Store.Execution.Running;
      return this.store.execution.program = program;
    }
  };

  Dispatcher.prototype.killProgram = function() {
    if (this.store.execution.status !== Store.Execution.Stopping) {
      this.store.execution.status = Store.Execution.Stopping;
      this.store.execution.program = null;
      return this.store.editor.ornamentalCode = TextConverter.decorate(this.store.editor.rowCode);
    }
  };

  Dispatcher.prototype.stopBreaking = function() {
    if (this.store.execution.status === Store.Execution.Breaking) {
      return this.store.execution.status = Store.Execution.Running;
    }
  };

  Dispatcher.prototype.stepProgram = function() {
    var ast, code, line, program, valueStr;
    if (this.store.execution.status === Store.Execution.Running) {
      program = this.store.execution.program;
      this.store.console.status = '';
      this.store.editor.ornamentalCode = TextConverter.decorate(this.store.editor.rowCode);
      if (program.terminated) {
        valueStr = Program.valueToString(program.cont);
        this.store.console.results.push(valueStr);
        this.killProgram();
        this.store.console.status = 'Program terminated';
      } else {
        ast = program.cont.context.ast;
        line = ast.location.start.line;
        if (this.store.editor.breakpointLineMap[line] && ast.leftMost === true) {
          if (program.cont.isIn() || program.cont.isBottom()) {
            this.store.execution.status = Store.Execution.Breaking;
            this.store.console.status = ("Breaking at " + ast.syntax + " ") + ("from " + (ast.location.start.line.toString()) + ":") + (ast.location.start.column + "<br>") + ("" + (Program.envToString(program.cont.context.env)));
            code = TextConverter.multiMark(this.store.editor.rowCode, [
              {
                location: ast.location,
                className: 'breaking-exp'
              }
            ]);
            this.store.editor.ornamentalCode = TextConverter.decorate(code);
          }
        }
      }
      return program.step();
    }
  };

  Dispatcher.prototype.keytyped = function(time) {
    return this.store.editor.lastKeytypedTime = time;
  };

  Dispatcher.prototype.focusEditor = function() {
    return this.store.editor.focusing = true;
  };

  Dispatcher.prototype.blurEditor = function() {
    return this.store.editor.focusing = false;
  };

  Dispatcher.prototype.setCurrentTime = function(time) {
    return this.store.currentTime = time;
  };

  Dispatcher.prototype.toggleCaretFlashing = function() {
    return this.store.editor.caretFlashing = !this.store.editor.caretFlashing;
  };

  Dispatcher.prototype.setCaretVisible = function() {
    return this.store.editor.caretVisible = !this.store.editor.focusing ? false : this.store.nowTyping(500) || this.store.editor.caretFlashing;
  };

  Dispatcher.prototype.toggleBreakpoint = function(lineNum) {
    if (this.store.editor.breakpointLineMap[lineNum] === true) {
      return this.store.editor.breakpointLineMap[lineNum] = false;
    } else {
      return this.store.editor.breakpointLineMap[lineNum] = true;
    }
  };

  return Dispatcher;

})();

if (typeof exports !== "undefined" && exports !== null) {
  exports.Store = Store;
  exports.Dispatcher = Dispatcher;
}
