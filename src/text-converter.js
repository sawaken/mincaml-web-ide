// Generated by CoffeeScript 1.10.0
var TextConverter;

TextConverter = (function() {
  function TextConverter() {}

  TextConverter.highlight = function(code) {
    var intP, keyP, valueP;
    keyP = /(\b)(in|let|rec|if|then|else)(\b)/g;
    intP = /(\b)([0-9]+)(\b)/g;
    valueP = /(\b)(true|false|unit)(\b)/g;
    return code.replace(keyP, '$1<span class="key-word">$2</span>$3').replace(intP, '$1<span class="int-word">$2</span>$3').replace(valueP, '$1<span class="value-word">$2</span>$3');
  };

  TextConverter.escapeTag = function(rowCode) {
    return rowCode.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  };

  TextConverter.toHtml = function(code) {
    return code.replace(/\r\n|\r|\n/g, '<br>').replace(/\s\s/g, ' &nbsp;').replace(/<br>\s/g, '<br>&nbsp;');
  };

  TextConverter.decorate = function(code) {
    return this.toHtml(this.highlight(code));
  };

  TextConverter.insert = function(string, pos, inserted) {
    return string.substr(0, pos) + inserted + string.substr(pos);
  };

  TextConverter.mark = function(rowCode, location, className) {
    var i, idx, len, line, markedLines, pos, ref;
    markedLines = [];
    ref = this.lines(rowCode);
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      line = ref[idx];
      if (idx === location.end.line - 1) {
        pos = location.end.column - 1;
        line = this.insert(line, pos, '</span>');
      }
      if (idx === location.start.line - 1) {
        pos = location.start.column - 1;
        line = this.insert(line, pos, '<span class="' + className + '">');
      }
      markedLines.push(line);
    }
    return markedLines.join('\n');
  };

  TextConverter.multiMark = function(rowCode, specs) {
    var i, l, len, res, sortedSpecs, spec;
    sortedSpecs = specs.sort((function(_this) {
      return function(a, b) {
        if (a.location.start.offset < b.location.start.offset) {
          return 1;
        } else {
          return -1;
        }
      };
    })(this));
    res = rowCode;
    for (i = 0, len = sortedSpecs.length; i < len; i++) {
      spec = sortedSpecs[i];
      l = spec.location;
      if (l.start.line === l.end.line && l.start.column === l.end.column) {
        continue;
      }
      res = this.mark(res, spec.location, spec.className);
    }
    return res;
  };

  TextConverter.lines = function(rowCode) {
    return rowCode.split(/\r\n|\r|\n/);
  };

  TextConverter.caret = function(rowCode, pos) {
    var lines;
    lines = rowCode.replace(/\r\n/g, '\n').substr(0, pos).split(/\r\n|\r|\n/);
    return {
      leftString: lines[lines.length - 1],
      line: lines.length
    };
  };

  return TextConverter;

})();

if (typeof exports !== "undefined" && exports !== null) {
  exports.TextConverter = TextConverter;
}
